<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title></title>
    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="css/slides-extended.css" />
    <link rel="stylesheet" href="dist\theme\black.css" id="theme" />
    <link rel="stylesheet" href="plugin\highlight\zenburn.css" />
    <link rel="stylesheet" href="plugin/customcontrols/style.css">
    <link rel="stylesheet" href="plugin/chalkboard/style.css">

    <link rel="stylesheet" href="plugin/reveal-pointer/pointer.css" />


    <script defer src="dist/fontawesome/all.min.js"></script>
    <script defer src="plugin/load-mathjax.js"></script>

    <script type="text/javascript">
        function pageInIframe() {
            return (window.location !== window.parent.location);
        }

        let forgetPop = true;
        function onPopState(event) {
            if(forgetPop){
                forgetPop = false;
            } else if( pageInIframe()) {
                parent.postMessage(event.target.location.href, "app://obsidian.md");
            }
        }
        window.onpopstate = onPopState;
        window.onmessage = event => {
            if(event.data == "reload"){
                window.document.location.reload();
            }
            forgetPop = true;
        }

        function fitElements() {
            const itemsToFit = document.getElementsByClassName('fitText');
            for (const item in itemsToFit) {
                if (Object.hasOwnProperty.call(itemsToFit, item)) {
                    const element = itemsToFit[item];
                    fitElement(element, 1, 1000);
                    element.classList.remove('fitText');
                }
            }
        }

        function fitElement(element, start, end) {

            let size = (end + start) / 2;
            element.style.fontSize = `${size}px`;

            if (Math.abs(start - end) < 1) {
                while (element.scrollHeight > element.offsetHeight) {
                    size--;
                    element.style.fontSize = `${size}px`;
                }
                return;
            }

            if (element.scrollHeight > element.offsetHeight) {
                fitElement(element, start, size);
            } else {
                fitElement(element, size, end);
            }
        }

        document.onreadystatechange = () => {
            fitElements();
            if (document.readyState === 'complete') {
                if (pageInIframe() && window.location.href.indexOf("?export") != -1){
                    parent.postMessage(event.target.location.href, "app://obsidian.md");
                }
                if (window.location.href.indexOf("print-pdf") != -1){
                    let stateCheck = setInterval(() => {
                        clearInterval(stateCheck);
                        window.print();
                    }, 250);
                }
            }
        };
    </script>
</head>

<body>
    <div class="reveal">
        <div class="slides"><section  data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Every tree in the forest
Dynamic audio clustering

> Slides: slides link    #todo
> Example Source: source link   #todo
</div></script></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Introduction
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Who I am

<div class="callout callout-color7" data-type="error">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-bolt" ></i>

</div>
<div class="callout-title-inner">
Kiera Lord  (@Cratesmith)  
</div>
</div>
<div class="callout-content">
Officially: Senior Gameplay Programmer @ Gameloft Brisbane
</div>
</div>
<!-- .element: style="font-size: 50%" "="true" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### Some stuff I've done

-  PS2/XB: **Destroy All Humans 2**
-  360/PS3: **The Dark Knight (Unreleased)**
-  Wii: **Next big thing (Unreleased)**
-  Web: **Alternator**
-  PC/PS3: **Vessel**
-  iOS/Droid: **Sim Cell**
-  iOS/Droid: **Codebreakers**
-  PC/Mac: **Kinect & VR support for Tail Drift**
-  GearVR: **Small** Â **(unreleased)**
-  Cardboard: **RACQ Bike VR**
-  GearVR: **Zombie Nom Nom**
-  Switch/PS4/Xbone: **Windbound
-  PC: **Cosy Caravan**
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### What to expect from this talk
  
* My goal is that everyone to get a high level of how everything works, but not all the details. 
	* Programmers I'm hoping will understand how the system work in detail 
	* Audio designers I'm hoping will understand enough how design sounds/events/parameters to work with the system.
<br></br>  
* Like all my talks, this is going to be an onslaught of information. Don't feel like you need to understand every last detail.

* This presentation is an introduction, with the slides/demo/recordings/source code containing more detail that you can refer to later.
<br></br>
* Some parts of this talk will be a bit rough. There really wasn't enough time to finish the demo I wanted to prepare AND redesign this talk to fit in the audio track.
</div></script></section></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# The problem we're trying to solve
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Volumetric audio is hard

* It's where we have -lots- of things that need to make sounds
* Some examples:
	* Liquid simulation sounds
	* Spatial ambience from foliage
	* Sounds for crowds/traffic/mass characters
<br></br>
* We can't just play more sounds to get around this problem.
	* We'd use up cpu/memory/available voices
	* It'd sound terrible due to phasing/destructive interference etc.
<br></br>
* Common solutions to these problems are
	* Ambience: Hand placed audio emitters or ambience volumes. 
	* Mass Sounds: Bespoke, feature specific systems to play each sound
	* Fallback: Reduce maximum voice count and just hope for the best
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## The solution we're exploring

* Instead of having one sound per thing, we want to group them based on proximity and play a shared sound to represent multiple things at once.
<br></br>  
* We give that sound a parameter for "number of things" so the sound can change depending on how many their are (plus any other parameters the sound needs)
<br></br>
* A good example of this is bullet impact sounds from a minigun. If we played a unique sound for each hit... it wouldn't be great. But we could play a sound at the position of several hits with a parameter for "how many bullets was that"
<br></br>
* Auditory stream segregation: how our brains group sounds. (orchestra example)
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## The theory behind this 

Auditory stream segregation
* When we can tell sounds apart VS when our brains group sounds together.
* Different factors contribute to how likely we will notice (or segregate) a sound.
	* Rate of change (especially sudden changes)
	* Directionality
	* Volume / Attenuation (distance fade)
	* Pitch
	* Focus of attention
	* Personal differences
	<br></br>
	
* Huge area of research, but for this talk we're only ever even considering only a few of the factors on this slide

* Our goal is to play combined sounds only for things that the player would already be grouping together in this way.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Moving on

Lets look at a relatively simple, if limited way to do this
</div></script></section></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Worldspace Clustering
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### What worldspace clustering is/isn't good for

<div class="callout callout-color3" data-type="check">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-check" ></i>

</div>
<div class="callout-title-inner">
Good for
</div>
</div>
<div class="callout-content">
Sounds in 2D games

Short "impact" sounds, when there could be a lot of impacts
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left; width: 90%" -->

<div class="callout callout-color6" data-type="fail">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-times" ></i>

</div>
<div class="callout-title-inner">
Bad for
</div>
</div>
<div class="callout-content">
Distant ambience in 3D games (requires an unreasonable number)

Avoiding noticeable spatialization issues (If listener is very close to the cluster and can tell it's coming from a specific spot)
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left; width: 90%" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### Example: Water sounds in VESSEL

<video style="width: 1000px; object-fit: fill" controls=""><source src="Vessel-gameplay-watersounds.mp4" alt="" type="video/mp4" /></video>


* I worked on Vessel back in 2009.
* Like all games at the time it was a puzzle platformer with a unique mechanic: particle-based liquid physics simulation (and characters)
* One of my first tasks was finding a way to play reactive sounds for all that liquid.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### VESSEL: Types of clustered sounds

We had 3 types of sounds made from clusters of points
* Liquid collision (contact points from water hitting surfaces, stored for 0.5s)
* Liquid "rushing" (any water particles moving / under sufficient pressure)
* Liquid "fusion" (contact points where two liquids combined to form another, such as lava + water = steam, stored for 0.5s)
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### VESSEL: Sound parameters

<video style="width: 1000px; object-fit: fill" controls=""><source src="WaterRushingDemo GVYRsihvqVI.mp4" alt="" type="video/mp4" /></video>

* Sounds were made by clustering (grouping) these points based on proximity
  
* These clusters acted as sound emitters for all their points.
  
* Each sound type was parameterized with a "drop_count" parameter for the number of points, as well as some additional parameters depending on the sound type
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### Early Sound design considerations
Clusterable sounds seem to mostly fall into two categories

* Continuous/Looping sounds where fading in/out instances of the sound at different playback times isn't noticeable.

* Short "impact" sounds where lots of the same impact event happen close to one another at almost the same time.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### Early Sound design considerations - Continuous Sounds

* These sounds spatialize really well.

* They also benefit greatly from having additional sound parameters based on player observable or influenceable behaviour.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### Early Sound design considerations - Impact sounds

* In these cases we store short lived points where collisions occurred, and use clustering to merge multiple small "hits" into one bigger one.

* This isn't as impressive as the looping sounds, but it does handle large numbers of impacts better than limiting voice count, or cooldown timers.
  
* These sounds have a few complexities though
	* They need to use custom clusters that play a new sound if points are added, with a configurable minimum time between starting sounds
	  
	* They don't work well with sounds that have a very short attack & sustain... though if you delay the start of the sound by a frame it can make up for this.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### The method

Time to jump into how this works, <br>
It's going to get complicated for a bit.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

### The method: Lets define some terms

* Cluster type:<br> Definition & settings for a kind of parameterized sound which can take a "point count" parameter.
 <br><br>
* Point: <br>A position (and other data) we want to play a cluster type's sound from.  
	* Can be assigned to a single cluster at a time.
<br><br>
* Cluster:<br> A dynamically spawned sound emitter, representing multiple 'points'. 
	* Always located at the average position of the points assigned to it.
<br><br>
	  
* Capture Radius:<br> The maximum distance a point can be from the cluster without being unassigned from it.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  The method - Capture Radius
<br>
In this method a cluster's "capture radius" is relative to the number of points assigned to the cluster:
* it increases with more points, shrinks with less points
<br><br>  
* there is a configurable minimum radius
  <br>(otherwise each cluster would likely only contain a single point)
<br><br>
* there is a maximum capture radius,
  <br>(to avoid runaway clustering)
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  The method - 1-3

<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
1. Re-position and update "capture radius" of clusters with changed points
</div>
</div>
<div class="callout-content">
This is to ensure clusters of moved points are in the correct locations before we assign points to clusters
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->


<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
2. Unassign any points that are outside the "capture radius" of the cluster they are assigned to.
</div>
</div>
<div class="callout-content">
This covers cases where the cluster or point has moved and is no longer close enough to belong to it's current cluster
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
3. Assign points to existing clusters they are within the "capture radius" of, or create new clusters to assign them to if that fails.
</div>
</div>
<div class="callout-content">
This creates any needed clusters and ensures as many points are clustered as possible, but we may still have overlapping clusters
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  The method - 4-6

<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
4. Merge smaller clusters into larger clusters who's "capture radius" fully overlaps all their points.
</div>
</div>
<div class="callout-content">
This eliminates clusters that are completely overlapped. I experimented with merging any overlapped point but results weren't better and it added a lot of complexity
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
5. Fade out sound for clusters that have no points, and destroy any clusters with no points that have fully faded out.
</div>
</div>
<div class="callout-content">
This is how clusters are removed
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
6. "Refresh" each changed cluster: starting the cluster's sound emitter and moving it to the the cluster's position, setting "point count" audio parameter as well as any custom ones.
</div>
</div>
<div class="callout-content">
This is when the cluster interprets data from its points and communicates this to the audio engine.
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: style="font-size: 50%; text-align: left" class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## The method - pseudocode
</div>

<!-- .element: style="font-size: 200%; text-align: center" -->

<div class="callout callout-color1" data-type="info">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-info-circle" ></i>

</div>
<div class="callout-title-inner">
Not covering this during the talk
</div>
</div>
<div class="callout-content">
This is here so you can refer to it later if you need to
</div>
</div>
<br>

#### When assigning/unassigning points from a cluster:
1. Move the cluster to the average position of it's assigned points
2. If the cluster's position was moved, mark all it's assigned points as changed.
3. Update the cluster's "capture radius"
4. Mark the cluster as changed
<br><br>
#### On an update when any points have changed:
1. Loop through all clusters that have changed or removed points
	1. Move the cluster to the average position of it's assigned points
	2. If the cluster's position was moved, mark all it's assigned points as changed.
	3. Update the cluster's "capture radius"
	4. Mark the cluster as changed
<br><br>
2. Loop through all changed points
	1. If the point is assigned to a cluster and is outside the cluster's "capture radius": unassign it from the cluster.
	2. If the point is unassigned: search for an an existing cluster who's "capture radius" contains the point, if found assign the point to that cluster.
	3. If the point is still unassigned: try to spawn a new cluster, if successful assign the point to the new cluster.
	4. Finally: If the point is assigned, mark it as unchanged
<br><br>
3. Loop through all changed clusters: 
	1. Find any clusters with less points who's points all are within this cluster's capture radius and reassign those points to this cluster.
  <br><br>
4. Loop through all changed clusters:
	1. If the cluster has no points, remove it.
	2. Start the cluster's sound emitter if it's not already playing
	3. Update the sound emitter with the new position and "number of points" parameter (along with any other custom parameters)
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Moving on

Let's to move onto the new stuff
</div></script></section></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Perception based 3D clustering
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: style="font-size: 75%; text-align: left" class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  Basing Capture radius on auditory stream segregation
</div>

<!-- .element: style="font-size: 150%; text-align: center" -->


<video style="width: 1200px; object-fit: fill" controls=""><source src="Clusters_Unity - Main - Windows, Mac, Linux - Unity 2022.3.6f1_ _DX11_ 2025-10-03 23-44-05.mp4" alt="" type="video/mp4" /></video>

</div>

<!-- .element: style="text-align: center" -->

* We basically want to cluster sounds as much as we can *without* the player noticing, so it makes sense to base the method on stream segregation factors.
  
* Just considering Directionality and Attenuation as noticeable factors for now.
	* We don't want the angle between the cluster and any of it's points from the listener's perspective getting large enough that the player would notice.
	  
	* Similarly we don't want the distance from the cluster to a point to be large enough that the attenuation of the cluster's sound is noticeably incorrect.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  Distance based capture radius

 * We want the "capture radius" to be based on this "maximum unnoticeable error angle" from the perspective of the listener (or attenuation origin, whichever is closest). 

* This turns out to be the simple formula: 
	```
	CaptureRadius = MinDistance * MaxNoticableListenerSinRatio
	```


* Where this is the sin ratio constant
	```
	MaxNoticableListenerSinRatio = sin(MaxNoticableListenerAngle) 
	```

* This turns out to be a surprisingly useful representation for lots of settings in this method. Many things are distance relative and "angle at a distance" is a quite intuitive way to think about these.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Minimum capture radius for Attenuation origin
* One small but very helpful tweak I found it was to clamp distance the attenuation origin to a minimum value when calculating capture radius. 
<br><br>
* This means the capture radius will:
	* shrink to a minimum value if the Attenuation origin (3rd person character) approaches the cluster.
	* still shrink to zero as the Listener (camera) approaches the cluster
<br><br>
* This really cuts down on the number of clusters needed, and doesn't have a negative impact as the player is very unlikely to notice that the distance fade is slightly incorrect if they're this close to a cluster.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Changes to the previous method

In this method a cluster's "capture radius" is a factor of distance from the listener/attenuation origin.

The method is almost identical, however we'll need to add several new features once we've updated the method in order to handle all the edge cases of this change.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  The method - 1-4

<div class="callout callout-color9" data-type="quote">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-quote-left" ></i>

</div>
<div class="callout-title-inner">
1. Re-position and update "capture radius" of clusters with changed points
</div>
</div>
<div class="callout-content">
This is to ensure clusters of moved points are in the correct locations before we assign points to clusters
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->


<div class="callout callout-color8" data-type="example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
2. [NEW STEP!] Update "capture radius" of clusters if they have moved, or if the minimum distance to the listener/attenuation origin has changed.
</div>
</div>
<div class="callout-content">
This is to ensure clusters of moved points are in the correct locations before we assign points to clusters
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color9" data-type="quote">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-quote-left" ></i>

</div>
<div class="callout-title-inner">
3. Unassign any points that are outside the "capture radius" of the cluster they are assigned to.
</div>
</div>
<div class="callout-content">
This covers cases where the cluster or point has moved and is no longer close enough to belong to it's current cluster
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color9" data-type="quote">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-quote-left" ></i>

</div>
<div class="callout-title-inner">
4. Assign points to existing clusters they are within the "capture radius" of, or create new clusters to assign them to if that fails.
</div>
</div>
<div class="callout-content">
This creates any needed clusters and ensures as many points are clustered as possible, but we may still have overlapping clusters
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

###  The method - 5-7

<div class="callout callout-color9" data-type="quote">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-quote-left" ></i>

</div>
<div class="callout-title-inner">
5. Merge smaller clusters into larger clusters who's "capture radius" fully overlaps all their points.
</div>
</div>
<div class="callout-content">
This eliminates clusters that are completely overlapped. I experimented with merging any overlapped point but results weren't better and it added a lot of complexity
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color9" data-type="quote">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-quote-left" ></i>

</div>
<div class="callout-title-inner">
6. Fade out sound for clusters that have no points, and destroy any clusters with no points that have fully faded out.
</div>
</div>
<div class="callout-content">
This is how clusters are removed
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color9" data-type="quote">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-quote-left" ></i>

</div>
<div class="callout-title-inner">
7. "Refresh" each changed cluster: starting the cluster's sound emitter and moving it to the the cluster's position, setting "point count" audio parameter as well as any custom ones.
</div>
</div>
<div class="callout-content">
This is when the cluster interprets data from its points and communicates this to the audio engine.
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Moving On... What else is needed?

Unfortunately the cluster radius change adds a lot of new edge cases 

<div class="callout callout-color8" data-type="Example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
Point weight interpolation
</div>
</div>
<div class="callout-content">
Sounds teleporting their location happens lot more now and will be very noticable.

So we need a way to interpolate out the direction & volume jumps caused by reassigning points between clusters.
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->

<div class="callout callout-color8" data-type="Example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
Culling
</div>
</div>
<div class="callout-content">
It's easier to have large numbers of points in 3D worlds, so we need to efficiently distance cull points without the player noticing.

We also need a way to ensure that if we hit our limit of clusters for any sound type, those clusters are used for sounds close to the player.
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->


<div class="callout callout-color8" data-type="Example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
Custom point data / Custom audio parameters
</div>
</div>
<div class="callout-content">
Finally as this will get quite complicated, we can't rebuild this system for each new type of sound that has different parameters. It needs to be able to take custom per-point data and turn that into custom per-sound behaviour & audio parameters.
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->
</div></script></section></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Point-Weight based Interpolation
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: style="font-size: 75%; text-align: left" class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Interpolation?

<video style="object-fit: scale-down" controls=""><source src="Clusters_Unity - Main - Windows, Mac, Linux - Unity 2022.3.6f1_ _DX11_ 2025-10-03 23-45-32.mp4" alt="" type="video/mp4" /></video>

</div>

<!-- .element: style="font-size: 150%; text-align: center" -->


* As mentioned before, sudden changes are very noticeable. So having the position of a cluster's sound teleport to the average position of its points whenever points are added or removed is something we want to avoid. 

* The same goes for the point count and any other sound parameters the cluster is sending to the sound engine.


* Initially I tried to work around this by directly blending cluster positions / values, then I tried fading out clusters that changed significantly. Neither worked well at all.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Point-Weight Interpolation?

* The best solution I found was to have points between clusters transition between clusters over time. This works by each point having a "weight" percentage that can be split between multiple clusters. 

* Over time each point will increase its weight for the cluster it is assigned to until that weight reaches 100%, in doing so reducing weights for any other clusters until they become 0% and are removed.
  
* If a point is being culled (and not immediately), we just reduce all weights to 0% in this way. Once all weights are zero, the point's data can be safely archived (to be un-culled later) or deleted without the player noticing.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## How does this affect clusters?

* Clusters keep track of all "weight points" that have weight values with them. These are used for almost everything we send from the cluster to the audio enigne.

* The cluster's position doesn't change, the weighted average position of these "weight points" is used as the audio emitter position for the cluster.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Nice side effects

<div class="callout callout-color8" data-type="Example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
Automatic interpolation for "Number of points" audio parameter
</div>
</div>
<div class="callout-content">
We can also use the total weight from all "weight points" as our "number of points" audio parameter.
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->


<div class="callout callout-color8" data-type="Example">
<div class="callout-title">
<div class="callout-icon">
<i class="fas fa-list" ></i>

</div>
<div class="callout-title-inner">
Easy to blend custom audio parameters
</div>
</div>
<div class="callout-content">
Similarly most custom audio parameters from points are best handled by using the weighted average value from each "weight point".
</div>
</div>
<!-- .element: style="font-size: 75%; text-align: left" -->
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Moving on... 

We still need to cull points
</div></script></section></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Culling
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: style="font-size: 75%; text-align: left" class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Culling?
<video style="object-fit: scale-down" controls=""><source src="Clusters_Unity - Main - Windows, Mac, Linux - Unity 2022.3.6f1_ _DX11_ 2025-10-03 23-57-30.mp4" alt="" type="video/mp4" /></video>

</div>

<!-- .element: style="font-size: 150%; text-align: center" -->


* We only have a limited number of clusters for each sound type, so we need to ensure they're not too far away to hear. So we cull points that are too far away from the attenuation origin.
  
* To handle this each cluster type defines a maximum culling distance (usually equal to the maximum attenuation distance of the sound).

* We also want to ensure that if we don't have enough clusters for all objects around us, we prioritize using them on the closest ones to the attenuation origin.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Culling!

* In order to cull points without checking the distance to each point individually, we perform culling by the "source objects" that provide points first.

* If  a source's bounds are:
	 * Outside the culling distance: all the source's points are removed.
	 * Overlapping the culling distance: each point from the source is checked against the culling distance individually
	 * Fully inside the culling distance: none of the points are culled.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Interpolating culling

 * As mentioned earlier, we interpolate points using weights to avoid noticeable changes. And  culling is no exception to this. 
 
 * This is done by removing culled points from clusters, but still allowing culled points that have weights for clusters to interpolate those until the point is fully blended out.
   
 * Once blended out, the data for culled points is not deleted, instead it's just "culled" which prevents it being used.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

</div>


## Dynamic culling distance

<video style="width: 1000px; object-fit: fill" controls=""><source src="Clusters_Unity - Main - Windows, Mac, Linux - Unity 2022.3.6f1_ _DX11_ 2025-10-04 00-01-35.mp4" alt="" type="video/mp4" /></video>

</div>


* The other thing we need from culling is to allow us to prioritize using clusters close to the attenuation origin if we don't have enough clusters for all nearby points.

* To do this we simply remove the most distant cluster entirely by reducing the culling distance if we run out of clusters during an update.
  
* Then we only gradually increase the culling distance towards it's default if we are sufficiently below the "max clusters" limit for this cluster type (at least 2). 

* Despite the simplicity, this method seems to work incredibly thanks to the point-weight interpolation of culled points / clusters.
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Moving on... 

We still need to support custom point types so we can use custom audio parameters!
</div></script></section></section><section ><section data-markdown><script type="text/template"><!-- .slide: class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

# Custom point data / Custom audio parameters
</div></script></section><section data-markdown><script type="text/template"><!-- .slide: style="font-size: 75%; text-align: left" class="drop" template="" -->
<div class="" style="position: absolute; left: 0px; top: 0px; height: 1080px; width: 1440px; min-height: 1080px; display: flex; flex-direction: column; align-items: center; justify-content: center" absolute="true">

## Custom point data / Custom audio parameters
</div>

<!-- .element: style="font-size: 150%; text-align: center" -->


<video style="object-fit: scale-down" controls=""><source src="clusters_custom_points_clusters.mp4" alt="" type="video/mp4" /></video>

* To get good results, the system needs to allow the use of additional custom sound parameters on a per-cluster type basis.
  
* To do this, the system needs to support custom point data as inputs, and custom clusters that  can turn that into custom sound parameters.
  
* In the video above the cows are using a custom "speed" parameter based on movement, and a "agitation" parameter based on how much the player has chased them recently
</div></script></section></section></div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>

    <script src="plugin/zoom/zoom.js"></script>
    <script src="plugin/math/math.js"></script>
    <script src="plugin/mermaid/mermaid.js"></script>
    <script src="plugin/chart/chart.umd.js"></script>
    <script src="plugin/chart/plugin.js"></script>
    <script src="plugin/menu/menu.js"></script>
    <script src="plugin/customcontrols/plugin.js"></script>
    <script src="plugin/chalkboard/plugin.js"></script>
    <script src="plugin/reveal-pointer/pointer.js"></script>
    <script src="plugin/elapsed-time-bar/elapsed-time-bar.js"></script>

    <script>
        function extend() {
            const target = {};
            for (let i = 0; i < arguments.length; i++) {
                const source = arguments[i];
                for (const key in source) {
                    if (source.hasOwnProperty(key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        }

        function isLight(color) {
            let hex = color.replace('#', '');

            // convert #fff => #ffffff
            if (hex.length == 3) {
                hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}`;
            }

            const c_r = parseInt(hex.substr(0, 2), 16);
            const c_g = parseInt(hex.substr(2, 2), 16);
            const c_b = parseInt(hex.substr(4, 2), 16);
            const brightness = ((c_r * 299) + (c_g * 587) + (c_b * 114)) / 1000;
            return brightness > 155;
        }

        const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--r-background-color').trim();

        if (isLight(bgColor)) {
            document.body.classList.add('has-light-background');
        } else {
            document.body.classList.add('has-dark-background');
        }

        // default options to init reveal.js
        const defaultOptions = {
            controls: true,
            progress: true,
            history: true,
            center: true,
            transition: 'default', // none/fade/slide/convex/concave/zoom
            plugins: [
                RevealMarkdown,
                RevealHighlight,
                RevealZoom,
                RevealNotes,
                RevealMath.MathJax3,
                RevealMermaid,
                RevealChart,
                RevealCustomControls,
                RevealMenu,
                RevealPointer,
                RevealChalkboard,
                ElapsedTimeBar
            ],
            allottedTime: 3000 * 1000,
            mathjax3: {
                mathjax: 'plugin/math/mathjax/tex-chtml-full.js',
            },
            markdown: {
                gfm: true,
                mangle: false,
                pedantic: false,
                smartLists: false,
                smartypants: false,
            },
            mermaid: {
                theme: isLight(bgColor) ? 'default' : 'dark',
            },
            customcontrols: {
                controls: [
                    {
                        icon: '<i class="fa fa-pen-square"></i>',
                        title: 'Toggle chalkboard (B)',
                        action: 'RevealChalkboard.toggleChalkboard();'
                    },
                    {
                        icon: '<i class="fa fa-pen"></i>',
                        title: 'Toggle notes canvas (C)',
                        action: 'RevealChalkboard.toggleNotesCanvas();'
                    },
                ]
            },
            menu: {
                loadIcons: false
            }
        };

        if ( pageInIframe() ) {
            defaultOptions.scrollActivationWidth = 5;
        }

        // options from URL query string
        const queryOptions = Reveal().getQueryHash() || {};

        const options = extend(defaultOptions, {"controls":true,"progress":true,"slideNumber":true,"center":true,"transition":"slide","transitionSpeed":"default","width":"1440","height":"1080","margin":0.04}, queryOptions);
    </script>

    <script>
      Reveal.initialize(options);
    </script>
    <!-- created with Slides Extended reveal.html template -->
</body>
</html>
